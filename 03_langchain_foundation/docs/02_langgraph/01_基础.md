# LangGraph 基础

## 1. 概述

### 1.1 什么是 LangGraph？

LangGraph 是一个用于构建**有状态**、**多代理**应用程序的低级编排框架。它是 LangChain 生态系统的一部分，但与 LangChain 有明确的区分：

- **LangChain**：快速构建代理的高级框架，提供开箱即用的功能
- **LangGraph**：低级编排框架，提供更精确的控制和灵活性

### 1.2 核心优势

1. **状态管理**：内置的状态持久化和管理能力
2. **图形化工作流**：使用图（Graph）来表示和控制复杂的工作流
3. **灵活性**：提供两种 API（Graph API 和 Functional API）满足不同需求
4. **生产就绪**：支持持久化、中断、流式输出等生产级特性
5. **可观测性**：与 LangSmith 集成，提供完整的可观测性

### 1.3 适用场景

- 需要精确控制工作流的应用
- 复杂的多步骤 AI 系统
- 需要状态持久化的长时间运行任务
- 需要条件分支和动态路由的场景
- 多代理协作系统

---

## 2. 核心概念

### 2.1 图（Graph）

图是 LangGraph 的核心抽象，由**节点（Nodes）**和**边（Edges）**组成：

```
START → Node A → Node B → END
             ↓
           Node C
```

### 2.2 节点（Nodes）

节点是工作流中的**独立工作单元**，可以是：
- 一个 Python 函数
- LLM 调用
- 工具调用
- 自定义逻辑

节点的特点：
- 接收当前状态作为输入
- 返回状态更新作为输出
- 可以读取和修改图的状态

### 2.3 边（Edges）

边定义了节点之间的连接关系，控制执行流程：

#### 普通边（Normal Edges）
固定的、静态的连接：
```python
builder.add_edge("node_a", "node_b")  # node_a 总是连接到 node_b
```

#### 条件边（Conditional Edges）
基于状态动态决定下一个节点：
```python
builder.add_conditional_edges(
    "node_a",
    routing_function,  # 根据状态返回下一个节点名称
    {
        "path_1": "node_b",
        "path_2": "node_c",
    }
)
```

### 2.4 状态（State）

状态是在图中流动的数据结构，通常使用 `TypedDict` 定义：

```python
from typing_extensions import TypedDict

class State(TypedDict):
    messages: list[str]
    user_input: str
    result: str
```

状态的关键特性：
- **共享内存**：所有节点都可以访问和修改
- **类型安全**：使用 TypedDict 提供类型提示
- **可扩展**：可以定义不同的输入、输出和私有状态

### 2.5 状态模式（State Schema）

LangGraph 支持三种状态模式：

#### 单一状态
```python
class State(TypedDict):
    value: str

builder = StateGraph(State)
```

#### 输入/输出分离
```python
class InputState(TypedDict):
    question: str

class OutputState(TypedDict):
    answer: str

class OverallState(InputState, OutputState):
    pass

builder = StateGraph(
    OverallState,
    input_schema=InputState,
    output_schema=OutputState
)
```

#### 私有状态
不同节点可以访问不同的状态部分：
```python
class InputState(TypedDict):
    user_input: str

class OverallState(TypedDict):
    foo: str

class PrivateState(TypedDict):
    bar: str

def node_1(state: InputState) -> OverallState:
    return {"foo": state["user_input"]}

def node_2(state: OverallState) -> PrivateState:
    return {"bar": state["foo"]}
```

### 2.6 状态归约器（State Reducers）

使用 `Annotated` 类型定义状态如何合并：

```python
from typing import Annotated
from operator import add

class State(TypedDict):
    # 使用 add 归约器，新值会追加到列表
    aggregate: Annotated[list, add]
```

常用归约器：
- `operator.add`：追加列表、连接字符串
- 自定义函数：实现特定的合并逻辑

### 2.7 特殊节点

- **START**：图的入口点
- **END**：图的出口点

```python
from langgraph.graph import START, END

builder.add_edge(START, "first_node")
builder.add_edge("last_node", END)
```

---

## 3. Graph API

### 3.1 Graph API 概述

Graph API 是 LangGraph 的**声明式** API，通过显式定义图的结构来构建工作流。

**适用场景**：
- 需要可视化工作流结构
- 复杂的分支和并行处理
- 团队协作需要清晰的架构
- 需要精确控制执行流程

### 3.2 基本使用流程

#### 步骤 1：定义状态
```python
from typing_extensions import TypedDict

class State(TypedDict):
    messages: list[str]
    count: int
```

#### 步骤 2：创建图构建器
```python
from langgraph.graph import StateGraph

builder = StateGraph(State)
```

#### 步骤 3：定义节点函数
```python
def process_input(state: State):
    """处理输入"""
    return {"count": state["count"] + 1}

def generate_output(state: State):
    """生成输出"""
    return {"messages": ["处理完成"]}
```

#### 步骤 4：添加节点
```python
# 方式 1：使用函数名作为节点名
builder.add_node(process_input)

# 方式 2：自定义节点名
builder.add_node("custom_name", generate_output)
```

#### 步骤 5：添加边
```python
from langgraph.graph import START, END

# 添加普通边
builder.add_edge(START, "process_input")
builder.add_edge("process_input", "custom_name")
builder.add_edge("custom_name", END)
```

#### 步骤 6：编译图
```python
graph = builder.compile()
```

#### 步骤 7：执行图
```python
result = graph.invoke({"messages": [], "count": 0})
print(result)  # {'messages': ['处理完成'], 'count': 1}
```

### 3.3 完整示例：顺序处理

```python
import operator
from typing import Annotated
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END

# 定义状态
class State(TypedDict):
    aggregate: Annotated[list, operator.add]

# 定义节点
def node_a(state: State):
    print(f'Adding "A" to {state["aggregate"]}')
    return {"aggregate": ["A"]}

def node_b(state: State):
    print(f'Adding "B" to {state["aggregate"]}')
    return {"aggregate": ["B"]}

def node_c(state: State):
    print(f'Adding "C" to {state["aggregate"]}')
    return {"aggregate": ["C"]}

# 构建图
builder = StateGraph(State)
builder.add_node(node_a)
builder.add_node(node_b)
builder.add_node(node_c)

# 添加边
builder.add_edge(START, "node_a")
builder.add_edge("node_a", "node_b")
builder.add_edge("node_b", "node_c")
builder.add_edge("node_c", END)

# 编译并执行
graph = builder.compile()
result = graph.invoke({"aggregate": []})
print(result)  # {'aggregate': ['A', 'B', 'C']}
```

### 3.4 条件分支示例

```python
from typing import Literal
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END

class State(TypedDict):
    aggregate: list
    which: str  # 用于决定分支路径

def node_a(state: State):
    return {"aggregate": ["A"], "which": "c"}

def node_b(state: State):
    return {"aggregate": state["aggregate"] + ["B"]}

def node_c(state: State):
    return {"aggregate": state["aggregate"] + ["C"]}

# 条件路由函数
def conditional_edge(state: State) -> Literal["node_b", "node_c"]:
    # 根据状态决定下一个节点
    return state["which"]

# 构建图
builder = StateGraph(State)
builder.add_node(node_a)
builder.add_node(node_b)
builder.add_node(node_c)

builder.add_edge(START, "node_a")
builder.add_conditional_edges(
    "node_a",
    conditional_edge,
    {
        "node_b": "node_b",
        "node_c": "node_c",
    }
)
builder.add_edge("node_b", END)
builder.add_edge("node_c", END)

graph = builder.compile()
result = graph.invoke({"aggregate": [], "which": "c"})
print(result)  # {'aggregate': ['A', 'C'], 'which': 'c'}
```

### 3.5 并行处理示例

```python
builder = StateGraph(State)
builder.add_node("a", node_a)
builder.add_node("b", node_b)
builder.add_node("c", node_c)
builder.add_node("d", node_d)

# 从 a 分叉到 b 和 c（并行执行）
builder.add_edge(START, "a")
builder.add_edge("a", "b")
builder.add_edge("a", "c")

# b 和 c 都汇聚到 d
builder.add_edge("b", "d")
builder.add_edge("c", "d")
builder.add_edge("d", END)

graph = builder.compile()
```

执行流程：
```
START → A → B → D → END
         ↘ C ↗
```

### 3.6 持久化（Checkpointing）

添加持久化支持，允许保存和恢复执行状态：

```python
from langgraph.checkpoint.memory import InMemorySaver

# 创建检查点保存器
checkpointer = InMemorySaver()

# 编译时传入
graph = builder.compile(checkpointer=checkpointer)

# 使用线程 ID 执行
config = {"configurable": {"thread_id": "1"}}
result = graph.invoke({"count": 0}, config)

# 可以用相同的 thread_id 继续执行
result = graph.invoke({"count": result["count"]}, config)
```

---

## 4. Functional API

### 4.1 Functional API 概述

Functional API 是 LangGraph 的**命令式** API，允许使用标准 Python 函数、循环和条件语句来定义工作流。

**适用场景**：
- 为现有代码添加 LangGraph 特性
- 简单的线性工作流
- 不需要复杂分支的场景
- 希望代码更接近传统 Python 风格

### 4.2 核心装饰器

#### `@entrypoint`
定义工作流的入口点：
```python
from langgraph.func import entrypoint

@entrypoint()
def my_workflow(input_data: dict) -> dict:
    # 工作流逻辑
    return {"result": "完成"}
```

#### `@task`
定义可重用的任务单元：
```python
from langgraph.func import task

@task
def fetch_data(query: str) -> dict:
    """获取数据"""
    return {"data": f"Results for {query}"}

@task
def process_data(data: dict) -> str:
    """处理数据"""
    return f"Processed: {data['data']}"
```

### 4.3 基本使用

```python
from langgraph.func import entrypoint, task
from langgraph.checkpoint.memory import InMemorySaver

@task
def fetch_data(query: str) -> dict:
    """获取数据"""
    return {"data": f"Results for {query}", "count": 42}

@task
def process_data(data: dict) -> str:
    """处理数据"""
    return f"Processed: {data['data']} ({data['count']} items)"

@task
def validate_result(result: str) -> bool:
    """验证结果"""
    return "Processed" in result

@entrypoint(checkpointer=InMemorySaver())
def workflow(query: str):
    # 使用 .result() 获取任务返回值
    data = fetch_data(query).result()
    processed = process_data(data).result()

    if validate_result(processed).result():
        return {"status": "success", "result": processed}
    else:
        return {"status": "failed", "result": None}

# 执行工作流
result = workflow.invoke("machine learning papers")
print(result)
# {'status': 'success', 'result': 'Processed: Results for machine learning papers (42 items)'}
```

### 4.4 与 Graph API 混合使用

Functional API 和 Graph API 可以**混合使用**，因为它们共享相同的底层运行时：

```python
from langgraph.func import entrypoint
from langgraph.graph import StateGraph
from typing_extensions import TypedDict

# 使用 Graph API 定义子图
class State(TypedDict):
    foo: int

def double(state: State) -> State:
    return {"foo": state["foo"] * 2}

builder = StateGraph(State)
builder.add_node("double", double)
builder.set_entry_point("double")
some_graph = builder.compile()

# 在 Functional API 中调用图
@entrypoint()
def workflow(x: int) -> dict:
    # 调用 Graph API 定义的图
    result = some_graph.invoke({"foo": x})
    return {"bar": result["foo"]}

# 执行
result = workflow.invoke(5)
print(result)  # {'bar': 10}
```

### 4.5 调用其他 Entrypoint

```python
from langgraph.func import entrypoint
from langgraph.checkpoint.memory import InMemorySaver

checkpointer = InMemorySaver()

# 子工作流
@entrypoint()
def sub_workflow(inputs: dict) -> int:
    return inputs["value"] * 2

# 主工作流
@entrypoint(checkpointer=checkpointer)
def main_workflow(inputs: dict) -> int:
    # 调用子工作流
    value = sub_workflow.invoke({"value": inputs["x"]})
    return value + 1

result = main_workflow.invoke({"x": 5})
print(result)  # 11
```

---

## 5. API 选择指南

### 5.1 何时使用 Graph API？

选择 Graph API 的场景：

✅ **需要可视化工作流结构**
- 团队需要理解和维护复杂的工作流
- 需要生成工作流图表进行文档化

✅ **复杂的分支和条件逻辑**
- 多个条件分支
- 动态路由
- 并行处理多个路径

✅ **并行处理**
- 需要同时执行多个节点
- 扇出-扇入（fan-out/fan-in）模式

✅ **团队协作**
- 多人协作开发
- 需要清晰的架构定义
- 便于代码审查

✅ **精确控制**
- 需要精细控制每个步骤
- 复杂的状态管理
- 需要检查点和回溯

### 5.2 何时使用 Functional API？

选择 Functional API 的场景：

✅ **为现有代码添加 LangGraph 特性**
- 已有的 Python 代码需要持久化
- 不想重构现有代码结构
- 渐进式迁移

✅ **简单线性工作流**
- 顺序执行的步骤
- 没有复杂分支
- 类似传统函数调用

✅ **快速原型开发**
- 快速验证想法
- 不需要复杂架构
- 代码更接近传统 Python

✅ **偏好命令式编程**
- 团队更熟悉命令式风格
- 使用标准 Python 语法（if/else/for）
- 减少学习曲线

### 5.3 混合使用策略

**最佳实践**：根据需求混合使用两种 API

```python
# 使用 Graph API 构建复杂的子模块
research_agent = create_react_agent(model, tools, name="researcher")

# 使用 Functional API 构建简单的子模块
@task
def generate_joke(messages):
    return model.invoke([{"role": "system", "content": "Tell a joke"}] + messages)

@entrypoint()
def joke_agent(state):
    joke = generate_joke(state['messages']).result()
    return {"messages": state["messages"] + [joke]}

# 在主工作流中组合它们
from langgraph_supervisor import create_supervisor

workflow = create_supervisor(
    [research_agent, joke_agent],  # 混合使用两种 API
    model=model
)
```

### 5.4 对比总结

| 特性 | Graph API | Functional API |
|------|-----------|----------------|
| **编程风格** | 声明式 | 命令式 |
| **代码风格** | 图结构定义 | 传统 Python 函数 |
| **学习曲线** | 中等 | 低 |
| **可视化** | 容易生成图表 | 较难可视化 |
| **分支控制** | 显式条件边 | if/else 语句 |
| **并行处理** | 原生支持 | 需要额外实现 |
| **代码重构** | 需要重新定义图 | 最小改动 |
| **适用场景** | 复杂工作流 | 简单工作流 |
| **团队协作** | 结构清晰 | 类似常规代码 |

---

## 6. 实际应用示例

### 6.1 简单的对话机器人（Graph API）

```python
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END

class ChatState(TypedDict):
    messages: list[dict]
    response: str

def process_message(state: ChatState):
    """处理用户消息"""
    user_msg = state["messages"][-1]["content"]
    return {"response": f"你说了: {user_msg}"}

def should_continue(state: ChatState) -> str:
    """判断是否继续"""
    if "再见" in state["response"]:
        return "end"
    return "continue"

# 构建图
builder = StateGraph(ChatState)
builder.add_node("process", process_message)
builder.add_edge(START, "process")
builder.add_conditional_edges(
    "process",
    should_continue,
    {
        "continue": END,
        "end": END
    }
)

graph = builder.compile()

# 执行
result = graph.invoke({
    "messages": [{"role": "user", "content": "你好"}],
    "response": ""
})
print(result["response"])  # 你说了: 你好
```

### 6.2 数据处理流水线（Functional API）

```python
from langgraph.func import entrypoint, task

@task
def load_data(file_path: str) -> list:
    """加载数据"""
    # 模拟数据加载
    return [1, 2, 3, 4, 5]

@task
def transform_data(data: list) -> list:
    """转换数据"""
    return [x * 2 for x in data]

@task
def validate_data(data: list) -> bool:
    """验证数据"""
    return all(x > 0 for x in data)

@entrypoint()
def data_pipeline(file_path: str):
    # 加载数据
    data = load_data(file_path).result()

    # 转换数据
    transformed = transform_data(data).result()

    # 验证数据
    is_valid = validate_data(transformed).result()

    if is_valid:
        return {"status": "success", "data": transformed}
    else:
        return {"status": "failed", "data": []}

result = data_pipeline.invoke("data.csv")
print(result)  # {'status': 'success', 'data': [2, 4, 6, 8, 10]}
```

### 6.3 多步骤决策流程（Graph API）

```python
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END

class DecisionState(TypedDict):
    input: str
    category: str
    result: str

def categorize(state: DecisionState):
    """分类"""
    if "紧急" in state["input"]:
        return {"category": "urgent"}
    elif "重要" in state["input"]:
        return {"category": "important"}
    else:
        return {"category": "normal"}

def handle_urgent(state: DecisionState):
    return {"result": "立即处理: " + state["input"]}

def handle_important(state: DecisionState):
    return {"result": "优先处理: " + state["input"]}

def handle_normal(state: DecisionState):
    return {"result": "正常处理: " + state["input"]}

def route_by_category(state: DecisionState) -> str:
    return state["category"]

# 构建图
builder = StateGraph(DecisionState)
builder.add_node("categorize", categorize)
builder.add_node("urgent", handle_urgent)
builder.add_node("important", handle_important)
builder.add_node("normal", handle_normal)

builder.add_edge(START, "categorize")
builder.add_conditional_edges(
    "categorize",
    route_by_category,
    {
        "urgent": "urgent",
        "important": "important",
        "normal": "normal",
    }
)
builder.add_edge("urgent", END)
builder.add_edge("important", END)
builder.add_edge("normal", END)

graph = builder.compile()

# 测试
result = graph.invoke({"input": "紧急：系统故障", "category": "", "result": ""})
print(result["result"])  # 立即处理: 紧急：系统故障
```

---

## 7. 最佳实践

### 7.1 状态设计

**✅ 推荐做法**：
```python
# 使用 TypedDict 提供类型安全
from typing_extensions import TypedDict

class State(TypedDict):
    user_input: str
    processed_data: dict
    result: str

# 使用归约器管理列表状态
from typing import Annotated
from operator import add

class State(TypedDict):
    messages: Annotated[list, add]  # 自动追加
```

**❌ 避免**：
```python
# 不要使用普通 dict，缺少类型检查
state = {"user_input": "...", "result": "..."}
```

### 7.2 节点设计

**✅ 推荐做法**：
```python
# 节点职责单一
def fetch_data(state: State):
    """只负责获取数据"""
    return {"data": fetch_from_api()}

def process_data(state: State):
    """只负责处理数据"""
    return {"result": process(state["data"])}
```

**❌ 避免**：
```python
# 不要让一个节点做太多事情
def do_everything(state: State):
    data = fetch_from_api()
    result = process(data)
    validation = validate(result)
    return {"data": data, "result": result, "valid": validation}
```

### 7.3 错误处理

```python
def safe_node(state: State):
    try:
        result = risky_operation(state["input"])
        return {"result": result, "error": None}
    except Exception as e:
        return {"result": None, "error": str(e)}

# 在条件边中处理错误
def route_on_error(state: State) -> str:
    if state.get("error"):
        return "error_handler"
    return "next_step"
```

### 7.4 可观测性

```python
def logging_node(state: State):
    """添加日志以便调试"""
    print(f"Processing: {state}")
    result = process(state)
    print(f"Result: {result}")
    return result
```

### 7.5 测试

```python
# 单独测试节点函数
def test_process_node():
    state = {"input": "test"}
    result = process_node(state)
    assert result["output"] == "expected"

# 测试完整图
def test_graph():
    graph = builder.compile()
    result = graph.invoke({"input": "test"})
    assert result["output"] == "expected"
```

### 7.6 性能优化

**使用并行处理**：
```python
# 并行执行独立节点
builder.add_edge("start", "task_1")
builder.add_edge("start", "task_2")  # task_1 和 task_2 并行
builder.add_edge("task_1", "merge")
builder.add_edge("task_2", "merge")
```

**使用持久化避免重复计算**：
```python
checkpointer = InMemorySaver()
graph = builder.compile(checkpointer=checkpointer)

# 使用相同的 thread_id 可以恢复之前的状态
config = {"configurable": {"thread_id": "user_123"}}
```

---

## 8. 常见问题

### Q1: Graph API 和 Functional API 可以混用吗？

**答**：可以！两种 API 共享相同的运行时，可以无缝集成：

```python
# 在 Functional API 中调用 Graph
@entrypoint()
def workflow(x: int):
    result = some_graph.invoke({"value": x})
    return result

# 在 Graph 中调用 Functional API
def node(state: State):
    result = some_workflow.invoke(state["data"])
    return {"result": result}
```

### Q2: 如何调试 LangGraph？

**答**：
1. **添加打印语句**：在节点中添加 print 查看状态
2. **使用断点**：在节点函数中设置断点
3. **流式输出**：使用 `graph.stream()` 查看中间步骤
4. **LangSmith**：集成 LangSmith 获得完整的可观测性

```python
# 流式输出查看每一步
for step in graph.stream({"input": "test"}):
    print(step)
```

### Q3: 如何处理长时间运行的任务？

**答**：使用持久化（checkpointing）：

```python
from langgraph.checkpoint.memory import InMemorySaver

checkpointer = InMemorySaver()
graph = builder.compile(checkpointer=checkpointer)

# 任务可以被中断和恢复
config = {"configurable": {"thread_id": "task_123"}}
result = graph.invoke(initial_state, config)
```

### Q4: 节点返回值必须包含所有状态字段吗？

**答**：不需要。节点只需返回要**更新**的字段：

```python
class State(TypedDict):
    field_1: str
    field_2: str
    field_3: str

def my_node(state: State):
    # 只返回需要更新的字段
    return {"field_1": "new_value"}
    # field_2 和 field_3 保持不变
```

### Q5: 如何实现循环？

**答**：使用条件边创建循环：

```python
def should_continue(state: State) -> str:
    if state["count"] < 5:
        return "continue"
    return "end"

builder.add_conditional_edges(
    "process",
    should_continue,
    {
        "continue": "process",  # 循环回到 process
        "end": END
    }
)
```

---

## 9. 参考资源

### 官方文档
- [LangGraph 概述](https://langchain-ai.github.io/langgraph/concepts/low_level/)
- [Graph API 文档](https://langchain-ai.github.io/langgraph/how-tos/graph-api)
- [Functional API 文档](https://docs.langchain.com/oss/python/langgraph/functional-api)
- [API 选择指南](https://docs.langchain.com/oss/python/langgraph/choosing-apis)

### 相关资源
- [LangChain 文档](https://docs.langchain.com/)
- [LangSmith 平台](https://www.langchain.com/langsmith)
- [LangGraph GitHub](https://github.com/langchain-ai/langgraph)

### 学习路径
1. 先学习本文档（基础部分）
2. 实践简单的示例项目
3. 学习高级特性（持久化、中断、流式输出）
4. 构建生产级应用

---

## 总结

LangGraph 提供了两种强大的 API 来构建有状态的 AI 应用：

- **Graph API**：适合复杂的、需要精确控制的工作流
- **Functional API**：适合简单的、线性的工作流

两种 API 可以混合使用，根据具体需求选择最合适的方式。掌握这两种 API 后，你就可以构建从简单到复杂的各种 AI 应用了。

下一步建议学习 LangGraph 的高级特性，包括持久化、中断处理、内存管理和流式输出等。
