# Deep Agents 高级特性

本文档详细介绍 Deep Agents 的高级特性，包括后端系统、子代理、长期记忆和人在环中机制。

## 概述

Deep Agents 通过以下高级特性支持复杂的代理任务：

- **Backends（后端）**: 可插拔的存储系统，支持不同的文件存储策略
- **Subagents（子代理）**: 任务委托机制，支持上下文隔离和专业化分工
- **Long-term memory（长期记忆）**: 跨会话的持久化存储
- **Human-in-the-loop（人在环中）**: 关键操作的人工审批机制

这些特性使 Deep Agents 能够处理需要多步骤规划、上下文管理和人工监督的复杂任务。

---

## 1. Backends（后端系统）

### 1.1 概念

Backend 是 Deep Agents 的核心抽象层，它定义了代理如何与文件系统交互。通过可插拔的后端系统，你可以：

- 控制文件的存储位置（内存、磁盘、云存储）
- 实现混合存储策略（部分文件持久化，部分临时）
- 添加安全限制和访问控制

### 1.2 后端类型

Deep Agents 提供以下内置后端：

#### StateBackend（状态后端）

**用途**: 临时存储，文件存储在代理的状态中，生命周期仅限当前会话。

**特点**:
- 默认后端
- 文件存储在内存中
- 会话结束后文件消失
- 适合临时工作文件

```python
from deepagents import create_deep_agent
from deepagents.backends import StateBackend

# StateBackend 是默认选项，无需显式指定
agent = create_deep_agent()

# 显式使用 StateBackend
agent = create_deep_agent(
    backend=StateBackend
)
```

#### FilesystemBackend（文件系统后端）

**用途**: 真实的磁盘文件操作，适合需要访问项目文件或持久化数据的场景。

**特点**:
- 文件保存到真实文件系统
- 支持沙箱模式（限制访问范围）
- 提供安全保护机制

```python
from deepagents import create_deep_agent
from deepagents.backends import FilesystemBackend

# 配置文件系统后端
agent = create_deep_agent(
    backend=FilesystemBackend(root_dir="/path/to/project")
)
```

**参数说明**:
- `root_dir`: 根目录路径，所有文件操作限制在此目录下
- `virtual_mode`: 可选，启用虚拟模式进行测试

#### StoreBackend（存储后端）

**用途**: 跨会话持久化存储，使用 LangGraph 的 Store 系统。

**特点**:
- 数据跨线程持久化
- 支持不同的存储实现（内存、数据库等）
- 适合长期记忆和知识库

```python
from deepagents import create_deep_agent
from deepagents.backends import StoreBackend
from langgraph.store.memory import InMemoryStore

# 创建持久化存储
store = InMemoryStore()

# 使用 StoreBackend
agent = create_deep_agent(
    backend=lambda rt: StoreBackend(rt),
    store=store
)
```

#### CompositeBackend（组合后端）

**用途**: 路由不同路径到不同后端，实现混合存储策略。

**特点**:
- 最灵活的后端选项
- 支持路径前缀路由
- 可组合多种后端类型
- 维护原始路径结构

```python
from deepagents import create_deep_agent
from deepagents.backends import CompositeBackend, StateBackend, StoreBackend
from langgraph.store.memory import InMemoryStore

# 配置混合后端
backend = lambda rt: CompositeBackend(
    default=StateBackend(rt),  # 默认使用临时存储
    routes={
        "/memories/": StoreBackend(rt)  # /memories/ 路径持久化
    }
)

agent = create_deep_agent(
    backend=backend,
    store=InMemoryStore()
)
```

### 1.3 后端选择指南

| 场景 | 推荐后端 | 原因 |
|------|---------|------|
| 临时工作文件 | StateBackend | 默认选项，简单快速 |
| 访问项目文件 | FilesystemBackend | 需要真实文件系统操作 |
| 跨会话记忆 | StoreBackend | 数据需要持久化 |
| 混合需求 | CompositeBackend | 灵活路由不同类型数据 |

### 1.4 自定义后端

你可以实现自定义后端（如 S3、数据库等）：

```python
from deepagents.backends.protocol import BackendProtocol, WriteResult, EditResult
from deepagents.backends.utils import FileInfo, GrepMatch

class S3Backend(BackendProtocol):
    def __init__(self, bucket: str, prefix: str = ""):
        self.bucket = bucket
        self.prefix = prefix.rstrip("/")

    def _key(self, path: str) -> str:
        return f"{self.prefix}{path}"

    def ls_info(self, path: str) -> list[FileInfo]:
        """List objects under the given path"""
        # Implementation for listing S3 objects
        pass

    def read(self, file_path: str, offset: int = 0, limit: int = 2000) -> str:
        """Read file content from S3"""
        # Implementation for reading from S3
        pass

    def grep_raw(self, pattern: str, path: str | None = None,
                 glob: str | None = None) -> list[GrepMatch] | str:
        """Search files with pattern"""
        # Implementation for searching
        pass

    def glob_info(self, pattern: str, path: str = "/") -> list[FileInfo]:
        """List files matching glob pattern"""
        # Implementation for glob matching
        pass

    def write(self, file_path: str, content: str) -> WriteResult:
        """Write new file to S3"""
        # Implementation for writing
        return WriteResult(path=file_path, files_update=None)

    def edit(self, file_path: str, old_string: str,
             new_string: str, replace_all: bool = False) -> EditResult:
        """Edit existing file"""
        # Implementation for editing
        pass

# 使用自定义后端
agent = create_deep_agent(
    backend=S3Backend(bucket="my-bucket", prefix="agents/")
)
```

---

## 2. Subagents（子代理）

### 2.1 概念

子代理允许主代理将复杂任务委托给专门的子代理，实现：

- **上下文隔离**: 子代理的详细工作不污染主代理的上下文
- **专业化分工**: 不同子代理可以专注于特定领域
- **独立配置**: 每个子代理可以有自己的模型、工具和提示词

### 2.2 工作原理

Deep Agents 通过内置的 `task` 工具实现子代理功能：

1. 主代理接收任务
2. 识别需要专业处理的子任务
3. 调用 `task` 工具创建子代理
4. 子代理独立执行任务
5. 结果返回给主代理

### 2.3 配置子代理

```python
from deepagents import create_deep_agent
from langchain_core.tools import tool

@tool
def get_weather(city: str) -> str:
    """Get current weather for a city"""
    return f"Weather in {city}: 72°F and sunny"

@tool
def internet_search(query: str) -> str:
    """Search the internet"""
    return f"Search results for: {query}"

# 定义专门的子代理
subagents = [
    {
        "name": "weather-specialist",
        "description": "Use this agent to get weather information for any location",
        "system_prompt": "You are a weather specialist. Use the get_weather tool.",
        "tools": [get_weather],
        "model": "openai:gpt-4o",  # 可以为每个子代理指定不同模型
    },
    {
        "name": "research-specialist",
        "description": "Use for deep research requiring multiple searches",
        "system_prompt": "You are a research specialist. Conduct thorough research.",
        "tools": [internet_search],
    }
]

# 创建主代理
agent = create_deep_agent(
    tools=[get_weather, internet_search],
    subagents=subagents,
    system_prompt="You are a helpful assistant. Delegate to specialists when appropriate."
)
```

### 2.4 子代理配置选项

每个子代理可以配置以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `name` | str | 子代理名称，主代理用此名称调用 |
| `description` | str | 说明子代理用途，帮助主代理决策 |
| `system_prompt` | str | 子代理的系统提示词 |
| `tools` | list | 子代理可用的工具列表 |
| `model` | str | 可选，指定子代理使用的模型 |
| `middleware` | list | 可选，添加额外的中间件 |
| `interrupt_on` | dict | 可选，配置人在环中审批 |

### 2.5 使用示例

```python
# 主代理自动委托任务给专门的子代理
result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "Research climate change impact on Tokyo and get current weather there"
    }]
})

# 工作流程：
# 1. 主代理识别需要研究和天气两个任务
# 2. 委托研究任务给 research-specialist
# 3. 委托天气查询给 weather-specialist
# 4. 整合两个子代理的结果
# 5. 返回综合答案

print(result["messages"][-1].content)
```

### 2.6 高级用法：自定义 LangGraph 子代理

对于复杂场景，可以传入预构建的 LangGraph 图作为子代理：

```python
from langgraph.graph import StateGraph
from langchain_core.messages import HumanMessage

# 创建自定义子代理图
def create_custom_subagent():
    workflow = StateGraph(...)
    # 配置复杂的工作流
    return workflow.compile()

# 使用自定义图作为子代理
subagents = [
    {
        "name": "complex-specialist",
        "description": "Handles complex multi-step workflows",
        "graph": create_custom_subagent(),  # 传入 LangGraph 图
    }
]

agent = create_deep_agent(subagents=subagents)
```

---

## 3. Long-term Memory（长期记忆）

### 3.1 概念

长期记忆允许代理在多个会话和线程之间保留信息，实现：

- **跨会话持久化**: 信息在不同对话中保留
- **知识积累**: 代理可以学习和记住用户偏好
- **上下文延续**: 避免重复提供相同信息

### 3.2 实现方式

长期记忆通过 `CompositeBackend` 结合 `StoreBackend` 实现：

```python
from deepagents import create_deep_agent
from deepagents.backends import CompositeBackend, StateBackend, StoreBackend
from langgraph.store.memory import InMemoryStore

# 创建持久化存储
store = InMemoryStore()

# 配置混合后端
backend = lambda rt: CompositeBackend(
    default=StateBackend(rt),  # 普通文件：临时存储
    routes={
        "/memories/": StoreBackend(rt)  # /memories/ 路径：持久化存储
    }
)

# 创建代理
agent = create_deep_agent(
    store=store,
    backend=backend,
    system_prompt="""You have access to long-term memory. Files prefixed with
    /memories/ persist across conversations. Use them to remember important
    information about users."""
)
```

### 3.3 使用示例

```python
# 第一次对话 - 保存信息
config1 = {"configurable": {"thread_id": "user-123"}}
agent.invoke({
    "messages": [{
        "role": "user",
        "content": "Remember my favorite color is blue. Write to /memories/preferences.txt"
    }]
}, config=config1)

# 稍后的对话 - 不同线程，但可以访问相同的记忆
config2 = {"configurable": {"thread_id": "user-456"}}
result = agent.invoke({
    "messages": [{"role": "user", "content": "What's my favorite color?"}]
}, config=config2)

# 代理自动从 /memories/preferences.txt 读取信息
print(result["messages"][-1].content)  # "Your favorite color is blue"
```

### 3.4 存储后端选择

| 后端 | 持久化程度 | 使用场景 |
|------|-----------|---------|
| InMemoryStore | 进程内持久化 | 开发和测试 |
| PostgresStore | 数据库持久化 | 生产环境 |
| RedisStore | 缓存式持久化 | 高性能需求 |

### 3.5 最佳实践

**1. 路径组织**

```python
# 推荐的路径结构
/memories/
  ├── user_preferences.txt      # 用户偏好
  ├── learned_facts.txt          # 学习的事实
  └── interaction_history.txt   # 交互历史
```

**2. 选择性持久化**

```python
# 使用 CompositeBackend 精确控制什么需要持久化
backend = lambda rt: CompositeBackend(
    default=StateBackend(rt),
    routes={
        "/memories/": StoreBackend(rt),           # 长期记忆
        "/knowledge/": StoreBackend(rt),          # 知识库
        "/work/": StateBackend(rt),               # 临时工作文件
    }
)
```

**3. 内存管理**

```python
# 在系统提示词中指导代理管理内存
system_prompt = """
Memory Management Protocol:
- Store user preferences in /memories/preferences.txt
- Keep conversation summaries in /memories/summaries/
- Use /work/ for temporary files (auto-deleted after session)
- Update memories when users provide new information
- Read from memories before answering questions about past interactions
"""
```

---

## 4. Human-in-the-Loop（人在环中）

### 4.1 概念

人在环中（HITL）机制允许在关键操作前暂停代理执行，等待人工审批：

- **安全控制**: 防止危险操作自动执行
- **审批工作流**: 实现多级审批流程
- **决策灵活性**: 支持批准、编辑、拒绝等多种决策

### 4.2 工作原理

HITL 基于 LangGraph 的中断（interrupt）机制：

1. 配置需要审批的工具
2. 代理调用敏感工具时暂停
3. 人工审查并做出决策
4. 根据决策继续或终止执行

### 4.3 基本配置

```python
from langchain_core.tools import tool
from deepagents import create_deep_agent
from langgraph.checkpoint.memory import MemorySaver

@tool
def delete_database(name: str) -> str:
    """Delete a database - requires approval"""
    return f"Deleted database: {name}"

@tool
def read_database(name: str) -> str:
    """Read from database - no approval needed"""
    return f"Contents of {name}"

# 配置需要审批的工具
agent = create_deep_agent(
    tools=[delete_database, read_database],
    checkpointer=MemorySaver(),  # 必需，用于保存中断状态
    interrupt_on={
        "delete_database": {
            "allowed_decisions": ["approve", "edit", "reject"]
        }
    }
)
```

### 4.4 决策类型

| 决策 | 说明 | 效果 |
|------|------|------|
| `approve` | 批准执行 | 工具按原参数执行 |
| `edit` | 修改参数 | 可以修改工具参数后执行 |
| `reject` | 拒绝执行 | 取消工具调用 |

### 4.5 完整工作流示例

```python
config = {"configurable": {"thread_id": "session-1"}}

# 启动代理任务
for event in agent.stream({
    "messages": [{"role": "user", "content": "Delete the old-data database"}]
}, config, stream_mode="values"):

    # 检测到中断
    if "__interrupt__" in event:
        interrupt_info = event["__interrupt__"]
        print(f"Tool: {interrupt_info['tool_name']}")
        print(f"Arguments: {interrupt_info['args']}")

        # 人工审查
        decision = input("Approve deletion? (approve/edit/reject): ")

        if decision == "approve":
            # 批准执行
            agent.update_state(config, {"decision": "approve"})

        elif decision == "edit":
            # 修改参数
            new_args = {"name": "safe-old-data"}  # 修改为更安全的名称
            agent.update_state(config, {
                "decision": "approve",
                "args": new_args
            })

        else:  # reject
            # 拒绝执行
            agent.update_state(config, {"decision": "reject"})

# 获取最终结果
final_state = agent.get_state(config)
print(final_state["messages"][-1].content)
```

### 4.6 子代理中的 HITL

子代理也可以配置人在环中审批：

```python
subagents = [
    {
        "name": "database-admin",
        "description": "Manages database operations",
        "tools": [delete_database, create_database],
        "interrupt_on": {
            "delete_database": {
                "allowed_decisions": ["approve", "reject"]
            },
            "create_database": {
                "allowed_decisions": ["approve", "edit", "reject"]
            }
        }
    }
]

agent = create_deep_agent(
    subagents=subagents,
    checkpointer=MemorySaver()
)
```

### 4.7 高级用法：条件审批

```python
# 仅对特定条件触发审批
def should_interrupt(tool_name: str, args: dict) -> bool:
    """自定义中断逻辑"""
    if tool_name == "delete_database":
        # 仅当删除生产数据库时需要审批
        return args.get("name", "").startswith("prod-")
    return False

# 在自定义中间件中实现条件审批逻辑
# (需要实现自定义中间件)
```

---

## 5. 最佳实践

### 5.1 后端选择

**开发阶段**:
```python
# 使用 StateBackend 快速迭代
agent = create_deep_agent()
```

**生产环境**:
```python
# 使用 CompositeBackend + 真实存储
from langgraph.store.postgres import PostgresStore

backend = lambda rt: CompositeBackend(
    default=StateBackend(rt),
    routes={
        "/memories/": StoreBackend(rt),
    }
)

agent = create_deep_agent(
    backend=backend,
    store=PostgresStore(connection_string="...")
)
```

### 5.2 子代理设计

**原则**:
1. **单一职责**: 每个子代理专注一个领域
2. **清晰描述**: 提供准确的 description，帮助主代理决策
3. **工具隔离**: 只给子代理必要的工具

**示例**:
```python
# 好的设计
subagents = [
    {
        "name": "data-analyst",
        "description": "Analyzes data using SQL queries and statistical tools",
        "tools": [sql_query, plot_chart, calculate_stats]
    },
    {
        "name": "report-writer",
        "description": "Writes formatted reports and documentation",
        "tools": [format_markdown, generate_pdf]
    }
]

# 避免的设计
subagents = [
    {
        "name": "helper",  # 名称不够具体
        "description": "Does various things",  # 职责不清晰
        "tools": [all_tools]  # 工具过多
    }
]
```

### 5.3 长期记忆管理

**结构化存储**:
```python
# 使用 JSON 格式存储结构化数据
system_prompt = """
Store user preferences in /memories/user_profile.json:
{
  "name": "...",
  "preferences": {...},
  "interaction_count": 0
}

Update this file when learning new information.
"""
```

**定期清理**:
```python
# 在系统提示词中建议清理策略
system_prompt = """
Memory Management:
- Keep /memories/current/ for active information
- Archive old data to /memories/archive/
- Delete obsolete files to save space
"""
```

### 5.4 HITL 配置

**分级审批**:
```python
# 根据风险级别配置不同的审批要求
interrupt_on = {
    # 高风险：需要审批
    "delete_production_data": {
        "allowed_decisions": ["approve", "reject"]
    },
    # 中风险：可编辑
    "modify_config": {
        "allowed_decisions": ["approve", "edit", "reject"]
    },
    # 低风险：不配置（自动执行）
}
```

**超时处理**:
```python
# 在生产环境中实现超时机制
# (需要自定义中间件或使用外部队列系统)
```

### 5.5 组合使用

综合运用所有特性：

```python
from deepagents import create_deep_agent
from deepagents.backends import CompositeBackend, StateBackend, StoreBackend
from langgraph.store.memory import InMemoryStore
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.tools import tool

@tool
def research(query: str) -> str:
    """Research a topic"""
    return f"Research results for {query}"

@tool
def delete_file(path: str) -> str:
    """Delete a file - requires approval"""
    return f"Deleted {path}"

# 配置完整的代理系统
agent = create_deep_agent(
    # 后端：混合存储
    backend=lambda rt: CompositeBackend(
        default=StateBackend(rt),
        routes={"/memories/": StoreBackend(rt)}
    ),
    store=InMemoryStore(),

    # 工具
    tools=[research, delete_file],

    # 子代理
    subagents=[
        {
            "name": "researcher",
            "description": "Deep research specialist",
            "tools": [research],
            "system_prompt": "Conduct thorough research on topics."
        }
    ],

    # 人在环中
    checkpointer=MemorySaver(),
    interrupt_on={
        "delete_file": {
            "allowed_decisions": ["approve", "reject"]
        }
    },

    # 系统提示词
    system_prompt="""You are an intelligent assistant with:
    - Long-term memory in /memories/ (persists across sessions)
    - Access to specialized research subagents
    - File operations that may require approval

    Use your capabilities wisely and maintain user context across conversations.
    """
)
```

---

## 6. 常见问题

### Q1: 如何在生产环境中使用真实数据库作为存储？

```python
from langgraph.store.postgres import PostgresStore

store = PostgresStore(
    connection_string="postgresql://user:pass@localhost/dbname"
)

agent = create_deep_agent(
    backend=lambda rt: CompositeBackend(
        default=StateBackend(rt),
        routes={"/memories/": StoreBackend(rt)}
    ),
    store=store
)
```

### Q2: 子代理可以访问主代理的文件吗？

可以。子代理共享相同的后端系统，可以读写主代理创建的文件。如果需要隔离，可以为子代理配置不同的路径前缀。

### Q3: HITL 的中断状态如何持久化？

使用持久化的 checkpointer（如 PostgresCheckpointer）：

```python
from langgraph.checkpoint.postgres import PostgresCheckpointer

checkpointer = PostgresCheckpointer(
    connection_string="postgresql://..."
)

agent = create_deep_agent(
    checkpointer=checkpointer,
    interrupt_on={...}
)
```

### Q4: CompositeBackend 的路由是否支持通配符？

目前仅支持精确前缀匹配。可以配置多个路由：

```python
routes={
    "/memories/": StoreBackend(rt),
    "/docs/": StoreBackend(rt),
    "/temp/": StateBackend(rt),
}
```

### Q5: 如何监控子代理的执行？

使用 LangSmith 进行跟踪：

```python
import os
os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_PROJECT"] = "deep-agents-project"

# 所有子代理的执行都会被追踪
agent = create_deep_agent(subagents=[...])
```

---

## 7. 参考链接

### 官方文档
- [Deep Agents 概述](https://docs.langchain.com/oss/python/deepagents/overview)
- [Deep Agents GitHub](https://github.com/langchain-ai/deepagents)
- [LangGraph Store 文档](https://langchain-ai.github.io/langgraph/reference/store/)
- [LangGraph Checkpointer 文档](https://langchain-ai.github.io/langgraph/reference/checkpoints/)

### 相关资源
- [Deep Agents 博客文章](https://blog.langchain.com/doubling-down-on-deepagents/)
- [Deep Agents 快速开始](https://github.com/langchain-ai/deepagents-quickstarts)
- [DataCamp 教程](https://www.datacamp.com/tutorial/deep-agents)

### 其他文档
- [LangChain 高级特性](../01_langchain/02_高级特性.md)
- [LangGraph 高级特性](../02_langgraph/02_高级特性.md)
- [Deep Agents 基础](./01_基础.md)
