# Deep Agents 基础

## 目录

1. [概述](#概述)
2. [核心概念](#核心概念)
3. [快速开始](#快速开始)
4. [自定义配置](#自定义配置)
5. [核心功能详解](#核心功能详解)
6. [代码示例](#代码示例)
7. [最佳实践](#最佳实践)
8. [参考链接](#参考链接)

---

## 概述

### 什么是 Deep Agents？

**Deep Agents** 是一个独立的 Python 库，专门用于构建能够处理**复杂、多步骤任务**的智能代理。它构建在 LangGraph 之上，并从 Claude Code、Deep Research 和 Manus 等应用中汲取灵感。

### 与 Shallow Agents 的区别

传统的"浅层代理"（Shallow Agents）使用 LLM 在循环中调用工具，这是最简单的代理架构形式。然而，这种架构在处理更长、更复杂的任务时往往会失败，因为它缺乏规划和长期执行能力。

**Deep Agents** 通过实现四个关键组件来克服这些限制：
1. **规划工具** - 任务分解和进度跟踪
2. **子代理** - 专门化任务委派
3. **文件系统访问** - 上下文管理
4. **详细提示词** - 明确的行为指导

### 与 LangChain/LangGraph 的关系

Deep Agents 建立在两个基础技术之上：
- **LangGraph** - 用于图执行和状态管理
- **LangChain** - 用于工具集成和模型集成

同时集成 **LangSmith** 用于可观测性、评估和部署能力。

### 主要优势

- **处理复杂任务** - 需要规划和分解的多步骤任务
- **管理大量上下文** - 通过文件系统工具防止上下文窗口溢出
- **持久化内存** - 跨会话保存和检索信息
- **专门化委派** - 通过子代理实现深度探索
- **生产就绪** - 通过 LangSmith 部署和监控

---

## 核心概念

### 四大关键能力

#### 1. 规划和任务分解（Planning and Task Decomposition）

Deep Agents 内置了 `write_todos` 工具，使代理能够：
- 将复杂任务分解为离散步骤
- 跟踪进度
- 随着新信息出现调整计划

```python
# 代理自动使用 write_todos 工具来管理任务
# 无需手动实现，开箱即用
```

#### 2. 子代理生成（Subagent Spawning）

专用的 `task` 工具允许代理：
- 将工作委派给子代理
- 保持上下文隔离
- 对特定子任务进行深入探索

**关键优势**：
- 避免主代理的上下文膨胀
- 专门化处理不同领域任务
- 并行执行提高效率

#### 3. 文件系统上下文管理

文件系统工具使代理能够：
- 将大量上下文卸载到内存
- 防止上下文窗口溢出
- 处理可变长度结果

**内置工具**：
- `ls` - 列出目录内容（带元数据）
- `read_file` - 读取文件内容（支持行号、偏移和限制）
- `write_file` - 创建新文件
- `edit_file` - 修改现有文件（精确字符串替换）
- `glob` - 基于模式的文件发现
- `grep` - 内容搜索（多种输出模式）

#### 4. 长期记忆（Long-Term Memory）

代理可以通过 LangGraph 的 Store 在对话之间持久化内存：
- 检索以前交互的信息
- 保存用户偏好
- 积累知识库
- 维护跨会话的研究进度

---

## 快速开始

### 安装步骤

```bash
# 安装 Deep Agents 和必要依赖
pip install deepagents tavily-python

# 或使用 uv（推荐）
uv pip install deepagents tavily-python
```

### 环境配置

设置必需的 API 密钥：

```bash
# Anthropic API（用于 Claude 模型）
export ANTHROPIC_API_KEY="your-api-key"

# Tavily API（用于网络搜索）
export TAVILY_API_KEY="your-tavily-api-key"

# 可选：OpenAI API
export OPENAI_API_KEY="your-openai-api-key"

# 可选：LangSmith（用于追踪和监控）
export LANGSMITH_API_KEY="your-langsmith-api-key"
```

### 最小化示例

```python
import os
from tavily import TavilyClient
from deepagents import create_deep_agent

# 1. 定义搜索工具
tavily_client = TavilyClient(api_key=os.environ["TAVILY_API_KEY"])

def internet_search(query: str, max_results: int = 5,
                   topic: str = "general",
                   include_raw_content: bool = False):
    """执行网络搜索并返回结果"""
    return tavily_client.search(
        query,
        max_results=max_results,
        include_raw_content=include_raw_content,
        topic=topic
    )

# 2. 创建代理
research_instructions = """你是一位专业研究员，任务是进行深入研究并撰写
精美的报告。你可以访问网络搜索工具来收集信息。"""

agent = create_deep_agent(
    tools=[internet_search],
    system_prompt=research_instructions
)

# 3. 执行查询
result = agent.invoke({
    "messages": [
        {"role": "user", "content": "What is LangGraph?"}
    ]
})

# 4. 查看结果
print(result["messages"][-1].content)
```

### 自动功能

Deep Agents 自动执行以下操作：
- ✅ 任务规划和分解
- ✅ 信息检索和整理
- ✅ 上下文管理（自动将大结果保存到文件）
- ✅ 子代理委派（如果配置）
- ✅ 报告综合

---

## 自定义配置

### 1. 模型选择（Model Selection）

Deep Agents 支持任何 LangChain 兼容的模型。

**默认模型**：`claude-sonnet-4-5-20250929`

```python
# 使用字符串标识符
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-20250514",
    tools=[...]
)

# 使用 OpenAI 模型
agent = create_deep_agent(
    model="openai:gpt-4o",
    tools=[...]
)

# 使用 LangChain 模型对象
from langchain_openai import ChatOpenAI

custom_model = ChatOpenAI(
    model="gpt-4o",
    temperature=0.7
)

agent = create_deep_agent(
    model=custom_model,
    tools=[...]
)
```

### 2. 系统提示词（System Prompt）

Deep Agents 自带受 Claude Code 启发的内置系统提示词，但你可以完全自定义。

```python
custom_prompt = """
你是一位专业的数据分析师，专注于：
1. 从原始数据中提取洞察
2. 创建清晰的可视化图表
3. 撰写简洁的分析报告

使用可用的工具来完成任务。对于复杂分析，先创建 todos 来规划步骤。
"""

agent = create_deep_agent(
    system_prompt=custom_prompt,
    tools=[...]
)
```

### 3. 工具配置（Tools）

你可以提供任何 LangChain 工具或自定义函数。

```python
from langchain_core.tools import tool

@tool
def calculate_statistics(data: list[float]) -> dict:
    """计算数据的基本统计信息"""
    import statistics
    return {
        "mean": statistics.mean(data),
        "median": statistics.median(data),
        "stdev": statistics.stdev(data) if len(data) > 1 else 0
    }

@tool
def get_weather(city: str) -> str:
    """获取城市的天气信息"""
    return f"The weather in {city} is sunny."

agent = create_deep_agent(
    tools=[calculate_statistics, get_weather],
    system_prompt="你是一位助手，可以提供天气信息和统计分析。"
)
```

### 4. 默认工具

每个 Deep Agent 自动获得以下工具：

| 工具 | 功能 | 说明 |
|------|------|------|
| `write_todos` | 更新待办事项列表 | 用于任务规划和跟踪 |
| `ls` | 列出文件 | 显示大小和修改时间 |
| `read_file` | 读取文件 | 支持行号、偏移和限制 |
| `write_file` | 创建文件 | 保存数据和结果 |
| `edit_file` | 修改文件 | 精确字符串替换 |
| `glob` | 文件模式匹配 | 查找特定文件 |
| `grep` | 内容搜索 | 多种输出模式 |
| `task` | 生成子代理 | 委派专门任务 |

### 5. Backend 配置（存储后端）

Deep Agents 支持四种存储后端：

```python
from deepagents import create_deep_agent
from deepagents.backends import (
    StateBackend,        # 临时存储（仅当前会话）
    FilesystemBackend,   # 本地磁盘
    StoreBackend,        # 持久化存储（跨会话）
    CompositeBackend     # 组合路由
)
from langgraph.store.memory import InMemoryStore
from langgraph.checkpoint.memory import MemorySaver

# 配置组合后端：临时 + 持久化
def make_backend(runtime):
    return CompositeBackend(
        default=StateBackend(runtime),  # 默认使用临时存储
        routes={
            "/memories/": StoreBackend(runtime)  # /memories/ 使用持久化
        }
    )

agent = create_deep_agent(
    backend=make_backend,
    store=InMemoryStore(),
    checkpointer=MemorySaver(),
    tools=[...]
)
```

**Backend 类型说明**：

| Backend | 持久化 | 跨会话 | 适用场景 |
|---------|--------|--------|----------|
| `StateBackend` | ❌ | ❌ | 临时草稿、中间结果 |
| `FilesystemBackend` | ✅ | ✅ | 本地项目、CI 环境 |
| `StoreBackend` | ✅ | ✅ | 生产部署、共享存储 |
| `CompositeBackend` | 混合 | 混合 | 组合策略（推荐） |

### 6. 子代理配置（Subagents）

定义专门化的子代理来处理特定任务。

```python
# 字典方式定义子代理
researcher_subagent = {
    "name": "deep-researcher",
    "description": "执行深入的研究任务，包括多轮搜索和综合分析",
    "system_prompt": """
你是一位专业研究员。对于收到的研究任务：
1. 使用 internet_search 工具收集信息
2. 将大量数据保存到文件系统
3. 返回 300-500 字的简洁摘要
""",
    "tools": [internet_search],
    "model": "anthropic:claude-sonnet-4-20250514"  # 可选：使用不同模型
}

agent = create_deep_agent(
    subagents=[researcher_subagent],
    tools=[internet_search]
)
```

**子代理最佳实践**：
- ✅ 编写具体的描述（帮助主代理选择正确的子代理）
- ✅ 包含详细的系统提示词（指导工具使用和输出格式）
- ✅ 最小化工具集（只包含必要工具）
- ✅ 返回简洁结果（建议 300-500 字摘要）
- ❌ 避免用于简单的单步任务

### 7. Human-in-the-Loop 配置

为敏感操作添加人工审批流程。

```python
from langchain_core.tools import tool
from deepagents import create_deep_agent
from langgraph.checkpoint.memory import MemorySaver

@tool
def delete_file(filename: str) -> str:
    """删除指定文件"""
    # 实际删除逻辑
    return f"Deleted {filename}"

# 配置需要人工审批的工具
agent = create_deep_agent(
    tools=[delete_file],
    checkpointer=MemorySaver(),  # HITL 必需
    interrupt_on={
        "delete_file": {
            "allowed_decisions": ["approve", "edit", "reject"]
        }
    }
)

# 使用
config = {"configurable": {"thread_id": "user-123"}}
result = agent.invoke(
    {"messages": [{"role": "user", "content": "Delete old_data.csv"}]},
    config=config
)

# 检查中断
if result.get("__interrupt__"):
    interrupts = result["__interrupt__"][0].value
    print(f"等待审批: {interrupts}")

    # 用户决策
    decisions = [{"type": "approve"}]  # 或 "edit" / "reject"

    # 恢复执行（使用相同的 thread_id）
    result = agent.invoke(
        Command(resume={"decisions": decisions}),
        config=config
    )
```

**决策类型**：
- `approve` - 使用原始参数执行
- `edit` - 修改参数后执行
- `reject` - 完全跳过该工具调用

---

## 核心功能详解

### Harness（代理框架）

Deep Agents 的 harness 是一个完整的代理框架，提供以下核心能力：

#### 大工具结果驱逐（Large Tool Result Eviction）

自动将超过 20,000 tokens 的工具结果保存到文件，防止上下文窗口饱和。

```python
# 自动处理，无需配置
# 当工具返回大量数据时，Deep Agents 会：
# 1. 检测结果大小
# 2. 自动保存到文件
# 3. 返回文件路径而非完整内容
```

#### 对话摘要（Conversation Summarization）

在上下文达到 170,000 tokens 时自动压缩历史记录，同时保留最近的 6 条消息。

```python
# 自动处理，保持上下文在合理范围内
# 确保长期任务不会耗尽上下文窗口
```

#### 提示词缓存（Prompt Caching - Anthropic）

对于使用 Anthropic 模型的代理，自动启用提示词缓存，减少重复处理系统提示词的开销（约 10x 加速）。

```python
# 使用 Anthropic 模型时自动启用
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",
    tools=[...]
)
# 系统提示词会被自动缓存
```

### Middleware（中间件架构）

Deep Agents 采用模块化中间件架构，由三个核心组件组成：

#### 1. TodoListMiddleware

提供任务规划能力。

```python
from deepagents.middleware import TodoListMiddleware

# 自定义 todo 提示词（可选）
todo_middleware = TodoListMiddleware(
    system_prompt="使用 write_todos 工具来规划和跟踪你的工作步骤..."
)
```

#### 2. FilesystemMiddleware

提供文件系统工具和上下文管理。

```python
from deepagents.middleware import FilesystemMiddleware

# 使用默认配置即可
# 自动提供 ls, read_file, write_file, edit_file, glob, grep
```

#### 3. SubAgentMiddleware

提供子代理委派能力。

```python
from deepagents.middleware import SubAgentMiddleware

# 定义子代理并自动获得 task 工具
```

---

## 代码示例

### 示例 1：基础研究代理

```python
import os
from tavily import TavilyClient
from deepagents import create_deep_agent

# 初始化搜索客户端
tavily = TavilyClient(api_key=os.environ["TAVILY_API_KEY"])

def internet_search(query: str, max_results: int = 5):
    """搜索互联网并返回相关结果"""
    return tavily.search(query, max_results=max_results)

# 创建研究代理
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",
    tools=[internet_search],
    system_prompt="""
你是一位专业的研究员。当收到研究任务时：
1. 使用 write_todos 创建研究计划
2. 使用 internet_search 收集信息
3. 将详细数据保存到文件
4. 综合发现并撰写报告
"""
)

# 执行研究
result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "研究 2025 年 AI 代理的最新发展趋势"
    }]
})

print(result["messages"][-1].content)
```

### 示例 2：带持久化内存的代理

```python
from deepagents import create_deep_agent
from deepagents.backends import CompositeBackend, StateBackend, StoreBackend
from langgraph.store.memory import InMemoryStore
from langgraph.checkpoint.memory import MemorySaver

# 配置混合存储：临时 + 持久化
def make_backend(runtime):
    return CompositeBackend(
        default=StateBackend(runtime),
        routes={"/memories/": StoreBackend(runtime)}
    )

agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",
    backend=make_backend,
    store=InMemoryStore(),
    checkpointer=MemorySaver(),
    system_prompt="""
你是一位个人助手。你可以：
- 在 /memories/ 目录保存用户偏好和重要信息（持久化）
- 在其他位置保存临时工作文件
"""
)

# 首次会话：保存偏好
config = {"configurable": {"thread_id": "user-alice"}}

result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "请记住：我喜欢简洁的回答，最多 3 个要点"
    }]
}, config=config)

# 新会话：使用相同 thread_id
result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "给我总结一下量子计算"
    }]
}, config=config)
# 代理会记住用户偏好并相应调整回答风格
```

### 示例 3：带子代理的复杂任务

```python
from langchain_core.tools import tool
from deepagents import create_deep_agent

@tool
def analyze_data(data_file: str) -> str:
    """分析数据文件并返回统计信息"""
    # 实际分析逻辑
    return "统计分析完成"

@tool
def create_visualization(data_file: str, chart_type: str) -> str:
    """创建数据可视化图表"""
    # 实际可视化逻辑
    return f"创建了 {chart_type} 图表"

# 定义专门化的子代理
data_analyst_subagent = {
    "name": "data-analyst",
    "description": "专门进行数据分析和可视化，处理统计计算和图表生成",
    "system_prompt": """
你是数据分析专家。执行以下步骤：
1. 使用 read_file 读取数据
2. 使用 analyze_data 进行统计分析
3. 使用 create_visualization 创建图表
4. 返回分析摘要（不超过 500 字）
""",
    "tools": [analyze_data, create_visualization],
    "model": "openai:gpt-4o"
}

# 创建主代理
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",
    subagents=[data_analyst_subagent],
    tools=[analyze_data, create_visualization],
    system_prompt="""
你是项目协调员。对于复杂的数据分析任务，使用 task 工具委派给 data-analyst 子代理。
"""
)

# 执行复杂任务
result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "分析 sales_2025.csv 并创建趋势图"
    }]
})
```

### 示例 4：Human-in-the-Loop 工作流

```python
from langchain_core.tools import tool
from deepagents import create_deep_agent
from langgraph.checkpoint.memory import MemorySaver
from langgraph.types import Command

@tool
def send_email(to: str, subject: str, body: str) -> str:
    """发送电子邮件"""
    # 实际发送逻辑
    return f"Email sent to {to}"

@tool
def delete_database(db_name: str) -> str:
    """删除数据库"""
    # 实际删除逻辑
    return f"Database {db_name} deleted"

# 创建需要审批的代理
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",
    tools=[send_email, delete_database],
    checkpointer=MemorySaver(),
    interrupt_on={
        "send_email": True,  # 所有决策类型
        "delete_database": {
            "allowed_decisions": ["approve", "reject"]  # 只允许批准或拒绝
        }
    }
)

# 执行敏感操作
config = {"configurable": {"thread_id": "session-001"}}

result = agent.invoke({
    "messages": [{
        "role": "user",
        "content": "给团队发送项目更新邮件"
    }]
}, config=config)

# 检查是否需要人工审批
if result.get("__interrupt__"):
    interrupts = result["__interrupt__"][0].value
    print(f"等待审批:")
    print(f"  工具: {interrupts['tool_name']}")
    print(f"  参数: {interrupts['args']}")

    # 获取用户决策
    user_choice = input("决策 (approve/edit/reject): ")

    if user_choice == "approve":
        decisions = [{"type": "approve"}]
    elif user_choice == "edit":
        new_subject = input("新主题: ")
        decisions = [{
            "type": "edit",
            "args": {"subject": new_subject}
        }]
    else:
        decisions = [{"type": "reject"}]

    # 恢复执行
    result = agent.invoke(
        Command(resume={"decisions": decisions}),
        config=config
    )

print("最终结果:", result["messages"][-1].content)
```

### 示例 5：自定义 Backend

```python
from deepagents import create_deep_agent
from deepagents.backends import BackendProtocol
from typing import Optional, Iterator

class S3Backend:
    """自定义 S3 存储后端"""

    def __init__(self, runtime, bucket_name: str):
        self.runtime = runtime
        self.bucket_name = bucket_name
        # 初始化 S3 客户端

    def ls_info(self, path: str) -> list:
        """列出 S3 对象"""
        # 实现 S3 列表逻辑
        pass

    def read(self, path: str, offset: int = 0, limit: Optional[int] = None) -> Iterator[str]:
        """从 S3 读取文件"""
        # 实现 S3 读取逻辑
        pass

    def write(self, path: str, content: str, overwrite: bool = False) -> str:
        """写入 S3 对象"""
        # 实现 S3 写入逻辑
        pass

    def edit(self, path: str, old: str, new: str, replace_all: bool = False) -> str:
        """编辑 S3 对象"""
        # 实现 S3 编辑逻辑
        pass

    def grep_raw(self, pattern: str, path: str, **kwargs) -> str:
        """在 S3 对象中搜索"""
        # 实现 S3 搜索逻辑
        pass

    def glob_info(self, pattern: str, path: str) -> list:
        """S3 对象模式匹配"""
        # 实现 S3 glob 逻辑
        pass

# 使用自定义后端
agent = create_deep_agent(
    backend=lambda rt: S3Backend(rt, bucket_name="my-agent-data"),
    tools=[...]
)
```

---

## 最佳实践

### 1. 任务规划

✅ **推荐做法**：
- 在系统提示词中明确指导代理使用 `write_todos` 进行规划
- 对于多步骤任务，要求代理先创建计划再执行
- 定期更新 todos 以反映进度

```python
system_prompt = """
对于复杂任务，先使用 write_todos 创建详细计划，然后逐步执行。
在完成每个步骤后更新 todos 状态。
"""
```

❌ **避免**：
- 不要跳过规划阶段直接执行
- 不要创建过于笼统的待办事项

### 2. 上下文管理

✅ **推荐做法**：
- 将大量数据保存到文件而非保留在消息中
- 使用描述性的文件名和路径
- 定期清理不再需要的临时文件

```python
system_prompt = """
当处理大量数据时：
1. 将原始数据保存到 /data/ 目录
2. 将分析结果保存到 /results/ 目录
3. 只在消息中返回摘要（不超过 500 字）
"""
```

❌ **避免**：
- 不要在消息中包含大量原始数据
- 不要重复读取相同的大文件

### 3. 子代理使用

✅ **推荐做法**：
- 为子代理编写清晰、具体的描述
- 限制子代理的工具集（只包含必要工具）
- 要求子代理返回简洁摘要
- 根据任务复杂度选择合适的模型

```python
subagent = {
    "name": "quick-researcher",
    "description": "执行快速网络搜索（1-3 次查询），适合回答简单问题",
    "system_prompt": "进行 1-3 次搜索，返回不超过 300 字的摘要",
    "tools": [internet_search],
    "model": "openai:gpt-4o-mini"  # 简单任务用更快的模型
}
```

❌ **避免**：
- 不要为简单任务创建子代理（增加开销）
- 不要让子代理返回过长的结果
- 不要给子代理提供不必要的工具

### 4. 内存管理

✅ **推荐做法**：
- 使用 `CompositeBackend` 分离临时和持久化存储
- 将用户偏好保存在 `/memories/` 目录
- 使用清晰的命名约定

```python
# 推荐的目录结构
/memories/          # 持久化（用户偏好、知识库）
  user_preferences.json
  knowledge_base.md

/workspace/         # 临时（当前任务）
  current_analysis.csv
  temp_results.txt
```

❌ **避免**：
- 不要将所有内容都保存为持久化
- 不要在临时存储中保存重要的用户数据

### 5. Human-in-the-Loop

✅ **推荐做法**：
- 为高风险操作启用 HITL
- 提供清晰的审批信息给用户
- 使用一致的 `thread_id`

```python
# 高风险操作需要审批
interrupt_on={
    "delete_file": True,
    "send_email": True,
    "execute_command": {"allowed_decisions": ["approve", "reject"]}
}
```

❌ **避免**：
- 不要为低风险操作启用 HITL（影响用户体验）
- 不要忘记配置 checkpointer（HITL 必需）

### 6. 错误处理

✅ **推荐做法**：
- 在系统提示词中指导代理如何处理错误
- 使用文件系统记录错误和调试信息
- 提供清晰的错误消息

```python
system_prompt = """
如果遇到错误：
1. 将错误信息保存到 /logs/error.log
2. 尝试替代方案
3. 如果无法恢复，向用户报告清晰的错误说明
"""
```

❌ **避免**：
- 不要让代理在遇到错误时立即放弃
- 不要返回原始的技术错误信息给用户

### 7. 性能优化

✅ **推荐做法**：
- 使用 Anthropic 模型以利用提示词缓存
- 合理使用子代理以并行处理
- 利用文件系统减少上下文大小

```python
# 使用支持缓存的模型
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-5-20250929",  # 支持缓存
    tools=[...]
)
```

❌ **避免**：
- 不要在每次调用时重新创建代理
- 不要让上下文窗口过度膨胀

---

## 参考链接

### 官方文档

- [Deep Agents Overview](https://docs.langchain.com/oss/python/deepagents/overview) - 概述和核心概念
- [Deep Agents Quickstart](https://docs.langchain.com/oss/python/deepagents/quickstart) - 快速开始指南
- [Deep Agents Customization](https://docs.langchain.com/oss/python/deepagents/customization) - 自定义配置
- [Deep Agents Harness](https://docs.langchain.com/oss/python/deepagents/harness) - 代理框架详解
- [Deep Agents Backends](https://docs.langchain.com/oss/python/deepagents/backends) - 存储后端配置
- [Deep Agents Subagents](https://docs.langchain.com/oss/python/deepagents/subagents) - 子代理使用
- [Deep Agents Human-in-the-Loop](https://docs.langchain.com/oss/python/deepagents/human-in-the-loop) - 人工审批流程
- [Deep Agents Long-Term Memory](https://docs.langchain.com/oss/python/deepagents/long-term-memory) - 持久化内存
- [Deep Agents Middleware](https://docs.langchain.com/oss/python/deepagents/middleware) - 中间件架构

### 代码和资源

- [GitHub - langchain-ai/deepagents](https://github.com/langchain-ai/deepagents) - 官方 GitHub 仓库
- [PyPI - deepagents](https://pypi.org/project/deepagents/) - Python 包页面
- [LangChain Blog - Deep Agents](https://blog.langchain.com/deep-agents/) - 设计理念和背景

### 相关技术

- [LangGraph 文档](https://langchain-ai.github.io/langgraph/) - 底层图执行框架
- [LangChain 文档](https://python.langchain.com/) - 工具和模型集成
- [LangSmith 文档](https://docs.smith.langchain.com/) - 可观测性和部署

### 参考应用

- Claude Code - Anthropic 的 AI 编程助手
- Deep Research - 深度研究应用
- Manus - AI 代理应用

---

## 下一步学习

完成本基础教程后，建议继续学习：

1. **核心能力深入**
   - 详细了解 Harness 的高级功能
   - 掌握不同 Backend 的使用场景
   - 学习 Middleware 自定义

2. **高级主题**
   - 多代理协作模式
   - 生产环境部署
   - 性能优化和监控
   - 安全和权限管理

3. **实践项目**
   - 构建研究助手
   - 开发代码分析工具
   - 创建数据分析代理
   - 实现客户服务机器人

祝学习顺利！
